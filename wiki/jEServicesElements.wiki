==jEmbedded Services and Other Elements==

The jEmbedded container can handle many different elements as Services, Dynamic Services, Components, Beans and AbstractBeans. All of them can be created and managed through annotations.

Can be deduced from the name of the framework that there is one kind of "special element" and that it's the embedded service:

*An embedded service it's a standalone one that can be invoked from within the same VM*

Many of the provided services within the container are embedded ones: JMS-Broker, Mule-Service, CFXServer-Service etc... most of that services can be used as no embedded as well, but I have prepared then (in some cases they already had an embedded implementation) and packaged them to be embedded so it can be used directly from the container, saving you the pain to install them, configuring them (well some little config it's needed, just the basic one from the annotations) etc... For example, you don't need to put jar's or classes in the classpath in order to the server to load them, or deploy a war etc etc..

=== Services ===

Usually offers functionality to any potential clients (for instance, an application or other service), implementing an interface that provides the contract for the client.

jEmbedded can produce definitions, make instances, hold and manage the lifecycle of any number or services that are annotated with a minimal configuration:

== Standard Container Managed implemented Service ==

This is the standard service, implementing an interface and extending an abstract class to  get its functionality(this is changing and in the next version of `jService` there won't be any need of abstract classes, won't be deprecated though).

{{{
@AnnotatedService(id="jdbcService", resources=DataSource.class,
managedElements="jdbcTemplate")
public class JdbcServiceImpl extends AbstractCMTService implements
		JdbcService {

	private JdbcTemplate jdbcTemplate;
	
	@Inject(ref="dataSource")
	private DataSource dataSource = null;
}}}

This is a Container Managed Service, it means that the container will managed it's lifecyle (init, start, stop, dispose).

The service can have some resources associated to it and injected but still are managed by the container (`DataSource.class`). Still the service can managed other services with the attribute `managedElements" handling its life cycle himself.

One of the benefits of the managed elements it's that as they don't live alone they have access to their environment and maybe to other's. The container injects a Context to the service (and the components as well), that provides access to the executing enviroment and the container itself. It means you can have access to other services or elements within the service:

{{{
JdbcService jdbcService = handler.getService("jdbcService");
jdbcService.getContext().getInstance("id");
}}}

or if you are executing the the container in other container environment as such as Spring 
you can have access to it:

{{{
JdbcService jdbcService = handler.getService("jdbcService");
ApplicationContext ctx = (ApplicationContext)jdbcService.getContext().getExternal();
}}}

A service can manage: services, components, beans  and entities.


=== Components ===

Usually provides support functionality to services or other components,  but usually it's not invoked directly by any client.


==== Types of Components ====

CMT Component (managed by the container) and un-managed component. A component can be initialized/disposed. If the component is of CMT type, the former operations only can be invoked by the container (an exception will be throw otherwise).

A component can manage: component, beans and entities.

jEmbedded can produce definitions, make instances, hold and manage the lifecycle of any number or  components that are annotated with a minimal configuration:

{{{
@AnnotatedComponent(id="supportComponent")
public class SupportComponent extends AbstractComponent {
	
	@Override
	protected void postConstruct() {
		System.out.println("PostConstruct");
	}
	
	@Override
	protected void release() {
		System.out.println("Release");
	}
	
	public String support() {
		return msg;
	}
}}}


=== Entities ===

Just a pojo, but does not follow the get/set bean standard. Usually are DOM classes, utility classes, etc...

jEmbedded can produce definition, make instances and hold any number of entities that are annotated with a minimal configuration. In this case the lifecycle of the entity is managed by the application nor the container (for example, could be diposed by a parent componen).

{{{
@AnnotatedBean(id="dependency")
public class TestDependency {
	
	@Inject(value="hi")
	private String msg = null;
}
}}}

An entity can manage entities or beans.

Note: in the next version (0.1.1) the annotation for entities will be different: ´@AnnotatedEntity()´

=== Beans ===

Just a pojo that follows the getter/setter standard.

jEmbedded can produce definitions, make instances and hold any number of beans  that are annotated with a minimal configuration. In this case the lifecycle of the bean is managed by the application nor the container (for example, could be diposed by a parent component).

{{{
@AnnotatedBean(id="dependency")
public class TestDependency {
	
	@Inject(value="hi")
	private String msg = null;

	public String getMsg() {
		return msg;
	}
}
}}}

An bean can manage entities or beans.