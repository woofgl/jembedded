#labels Featured
== Project Setup ==

Once you have installed the framework, you will need to declare the dependencies in your pom. 
*  The core dependency (jembedded-core).
{{{
                 <dependency>
			<groupId>org.jsemantic</groupId>
			<artifactId>jembedded-core</artifactId>
                        <version>0.1.3</version>
		</dependency>
}}}
*  Any service dependency you are planning to use. For instance, if you want to use the jetty-service you would need to include:
{{{

                 <dependency>
			<groupId>org.jsemantic.services</groupId>
			<artifactId>jetty-service</artifactId>
                        <version>0.4.0-SNAPSHOT</version>
		</dependency>
}}}

Now that you have the framework classes available to your project, you can start using it right away.

== How to use jEmbedded ==

There are many ways you could use jEmbedded:

  * Rich Applications Container: integrated with GWT/Spring MVC to create RIA applications (SOA oriented).

  * Rich Portal Application Provider: introducing the concepts of Gwlets/Widglets to power RIA portals.

  * Integration Container: as container for application integration, using an ESB, messaging services etc...

  * Web enviroment: can be used in any web enviroment, as a holder of a services layer, for example. Have a look at the case study  example as it shows the provided integration with SpringMVC. 

  * Standalone container: implementing services (just one or a layer hierarchy), that you can use in any application. Or just a container for your application.

  * Integrated with Spring: you can access Spring beans from jEmbedded or just create an ApplicationContext (as another service of the container) and access those beans.

  * Easy prototyping: create services fast and then test them with jIntegration-Test. You can do this from eclipse or using the maven pluging included. You don't need to install for example a mule server or a web server etc... For instance, it's faster to test your integration/soa designs this way. Have a look at the case study example for an example of this.



=== How to create a Service with jEmbeded ===

The core of any application logic must be a handful of services that handle it. The services can be created fast using the dynamic injection/creation provided with jEmbedded, that allows you to create services with just an abstract class (or interface)+annotations. 

This kind of services are created with composition (and managing) of other elements. You can add additional application logic implementing methods from other services or implementing a bpm process.

There are many ways you can create services with jEmbedded. Let's start with a simple service "Hello World" and using the `@AbstractAnnotatedService` annotation. This annotation is the most powerful of the framework and it's not only intended for abstract Services but for regular implemented Services as well. Of course, you could use the `@AnnotatedService` for the latter ones but then you would need to extend the the class using the AbstractCMService or the AbstractService abstract classes. You don't need to do this using the `@AbstractAnnotatedService` annotation. Keep in mind that the service returned it's a proxy class. You can 

== Hello world Service Example ==
 
1 - Create an annotation with the default configuration for your service (id, singleton, class, etc. + your custom attributes).

{{{
@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE, ElementType.METHOD })
public @interface HelloWorldAnnotatedService {
	
        // service id in the container
	String id() default "helloService";
        
        // service type to inherits
	Class<?> inherits() default AbstractAnnotatedService.class;
        
        //other services to load, none this time
	Class<?>[] resources();
        
        //msg attribute
        String msg() default="no message";
}
}}}

2- In this case we have choosen the `@AbstractAnnotedService` but we'll  create an regular class as we don't need abstract methods but we don't want to extend any abstract class.

{{{
@HelloWorld(msg="hello world")
public class HelloWorldService {

}
}}}

3- Add the attributes, methods etc you would need, in this case we need a String attibute and a service method:

{{{
@HelloWorld(msg="hello world")
public class HelloWorldService {

@Inject
private String msg;

public String getMessage(){
return msg;
}

}
}}}

The inject annotation will associate the msg attribute to the Service, populating it with the value from the custom annotation.

This value also can be populated using the properties service and a external properties file:

{{{
@Inject(val=${helloWorldService.msg}
}}}

4- Create a test unit using the jEmbedded integrations testing support.

{{{
@RunWith(IntegrationTestClassRunner.class)
@Container(instanceType=ContainerInstanceType.PROTOTYPE_BY_THREAD)

@Include(resources = {HelloWorldService.class})
public class HelloWorldServiceTest {

@Test
public void test() {
	HelloWorldService service =(HelloWorldService) Assert.getService("helloService");
		
	assertEquals("hello world", service.getMsg());
        // this is also valid
        
        Service helloService = (Service)Assert.getService("helloService");
        assertEquals("helloService", service.getId());
}	
}
}}}