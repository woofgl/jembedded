== Project Setup ==

Once you have installed the framework, you’d need to declare the dependencies in your pom. 
*  The core dependency (jembedded-core).
{{{
                 <dependency>
			<groupId>org.jsemantic</groupId>
			<artifactId>jembedded-core</artifactId>
                        <version>0.1.x</version>
		</dependency>
}}}
*  Any service dependency you are planning to use. For instance, if you want to use the jetty-service you need to include:
{{{

                 <dependency>
			<groupId>org.jsemantic.services</groupId>
			<artifactId>jetty-service</artifactId>
                        <version>0.4.0-SNAPSHOT</version>
		</dependency>
}}}

Now that you have the framework classes available to your project, you can start using it right away.

== How to use jEmbedded ==

There are many ways you could use jEmbedded:

  * Standalone framework: implementing services (just one or a layer hierarchy), that you can use in any application. Or just a container for your application.

  * Integrated with Spring: you can access spring beans from jEmbedded or just create an ApplicationContext (as another service of the container) and access those beans.

  * Web enviroment: can be used in any web enviroment, have a look at the invoicing-server example. It shows the provided integration with SpringMVC.

  * Easy prototyping: create services fast and then test them with jIntegration-Test. You can do this from eclipse or using the maven pluging included. You don't need to install for example a mule server or a web server etc... For example it's fast to test your integration/soa designs this way. Have a look at the invoicing-server example for an example of this (even though it's a bit complex for the sake of showing more jEmbedded features).


=== Services Examples & How to create them ===

The core of any application logic must be a handful of services that handle it. The services can be created fast using the dynamic injection/creation provided with jEmbedded, that allows you to create services with just and interface+annotations. This kind of services are created with composition (and managing) of other elements. You can add additional application logic implementing methods from other services.

=== Steps ==

1 – Create an interface with the methods you would need and extends the Service interface.

public interface EchoMuleService extends Service {
   public Service getMuleService();
}


2 - Annotate the service at a class level with the @AnnotatedService annotation.

{{{
@AnnotatedService(id="echoMuleService", resources=MuleServiceImpl.class, managedElements="muleService")
}}}

@AnnotatedService:

- id: service id in the container.

- resources: elements the service will use for composition, that will be handled by the container.

- managedElements: services managed by this service, that means that the service will handle their lifecycle (start&stop them), not the container.


For example let's say you want invoke a mule based service from your application, for instance the echo example that cames with the distribution just for testing.

Obviously you can do this from the mule directory etc.. but that's not fun and you can't import the example into your echo-application :)

For this matter you can just declare the mule service and client services dependencies in your pom:
{{{
                <dependency>
			<groupId>org.jsemantic.services</groupId>
			<artifactId>mule-service</artifactId>
			<version>0.1.0-SNAPSHOT</version>
		</dependency>
		<dependency>
			<groupId>org.jsemantic.services</groupId>
			<artifactId>mule-client-service</artifactId>
			<version>0.2.0-SNAPSHOT</version>
		</dependency>
}}}

All the services provided with jEmbedded follows the same packaging pattern,  they provide you with an interface, an implementation , some customs annotations and  a META-INF/xxx-service directory with the needed resources, usually a xxx-service.xml file(to use it from Spring or any other framework that uses its ApplicationContext), some properties files, some other configuration stuff etc... In fact this is the way you should package your services for distribution:

{{{
resources/
         META-INF/
                 xxx-service
                 /....config files
}}}

So basically to use a service you can:

*  Import it using the attribute resources with a class/interface depending how it was designed. This way you can externalize the configuration of your service using the @PropertiesService: `resources=MuleServiceImpl.class`

*  Using its custom annotation:

{{{
@MuleService(configurationFile="echo-config.xml")
public Service getMuleService();
}}}

The annotation can be declared at class level or method level. If you want to have access to it, the best way it's to declare method that will be dynamicly implemented  by the service.

{{{
MuleService muleService = echoService.geMuleService();
}}}

Importing the service this way has the restriction that the configuration it's fixed on the annotation. This is not an issue when you want to develop and distribute a service like this one, that is not likely to change.


3 - Annotate the methods and add the additional services you may need.

{{{
@AnnotatedService(id="echoMuleService", 
resources=MuleServiceImpl.class, managedElements="muleService")
public interface EchoMuleService extends Service {
	
	@Inject(ref="muleService")
	public MuleService getMuleService();
	
	@PropertiesService(propertiesFile=
             "META-INF/web-server/mule-echo-service.properties")
	public void getPropertiesService();
}
}}}

Note the I added the PropertiesService as it's needed to parse the properties file configuration (you can avoid this using the custom annotation), this service is used to compose the service, but it's not managed by the service. Also you don't need it to declare it as method (I did it for the sake of the example):

{{{

@PropertiesService(propertiesFile=
             "META-INF/web-server/mule-echo-service.properties")

@AnnotatedService(id="echoMuleService", 
resources=MuleServiceImpl.class, managedElements="muleService")
public interface EchoMuleService extends Service {
	
	@Inject(ref="muleService")
	public MuleService getMuleService();
}
}}}

4- At this point we could think that would be nice to add a method that actually invokes the model that mule service exposes. This model just echo whatever string you sent it so we add the following method:

{{{
public Object sendEchoMessage(String echoEndPoint, String message);
}}}

Now you may think that you have to write have an implementation class.. no you are wrong :), you can implement this functionality just using composition:






4 – Once the services (and its associated components and beans) are created and annotated you’ll need to create an instance of the jEmbedded container (or more than one, you are not restricted to one).

In order to do that you can use the EmbeddedHandlerFactory:

{{{
EmbeddedHandler handler = EmbeddedHandlerFactory.getInstance(Class<?>…classes);
}}}

The factory accepts an array of classes. You should include here the entry point to your services, for example: WebServerImp.class or if you running it from a test unit:

{{{
@WebClient
@Include(resources={WebServerImpl.class})
public class IntegrationWebServerTest {

……
EmbeddedHandler handler = EmbeddedHandlerFactory.getInstance(IntegrationWebServerTest.class);
}}}

The factory returns a handler to the created container that allows manipulating it:

{{{
handler.start(); // start the container.

WebServer server = (WebServer)handler.getService(“webServer”); // retrieves a service

ServletContext  servletContext = server.getServletContext()

handler.stop(); // stop and dispose the container.
}}}

5 - You may handle the service with a Repository as well.