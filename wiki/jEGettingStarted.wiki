#labels Featured
== Project Setup ==

Once you have installed the framework, you’d need to declare the dependencies in your pom. 
*  The core dependency (jembedded-core).
{{{
                 <dependency>
			<groupId>org.jsemantic</groupId>
			<artifactId>jembedded-core</artifactId>
                        <version>0.1.x</version>
		</dependency>
}}}
*  Any service dependency you are planning to use. For instance, if you want to use the jetty-service you need to include:
{{{

                 <dependency>
			<groupId>org.jsemantic.services</groupId>
			<artifactId>jetty-service</artifactId>
                        <version>0.4.0-SNAPSHOT</version>
		</dependency>
}}}

Now that you have the framework classes available to your project, you can start using it right away.

== How to use jEmbedded ==

There are many ways you could use jEmbedded:

  * Standalone framework: implementing services (just one or a layer hierarchy), that you can use in any application. Or just a container for your application.

  * Integrated with Spring: you can access spring beans from jEmbedded or just create an ApplicationContext (as another service of the container) and access those beans.

  * Web enviroment: can be used in any web enviroment, have a look at the invoicing-server example. It shows the provided integration with SpringMVC.

  * Easy prototyping: create services fast and then test them with jIntegration-Test. You can do this from eclipse or using the maven pluging included. You don't need to install for example a mule server or a web server etc... For example, it's faster to test your integration/soa designs this way. Have a look at the invoicing-server example for an example of this (even though it's a bit complex for the sake of showing more jEmbedded features).


=== Services Examples & How to create them ===

The core of any application logic must be a handful of services that handle it. The services can be created fast using the dynamic injection/creation provided with jEmbedded, that allows you to create services with just a interface+annotations. This kind of services are created with composition (and managing) of other elements. You can add additional application logic implementing methods from other services.

=== Steps ==

1 – Create an interface with the methods you would need and extends the Service interface.

public interface EchoMuleService extends Service {
   public Service getMuleService();
}


2 - Annotate the service at a class level with the @AnnotatedService annotation.

{{{
@AnnotatedService(id="echoMuleService", resources=MuleServiceImpl.class, managedElements="muleService")
}}}

`@AnnotatedService`:

- id: service id in the container.

- resources: elements the service will use for composition, that will be handled by the container.

- managedElements: services managed by this service, that means that the service will handle their lifecycle (start&stop them), not the container.


For example let's say you want invoke a mule based service from your application, for instance the echo example that cames with the distribution just for testing.

Obviously you can do this from the mule directory etc.. but that's not fun and you can't import the example into your echo-application :)

For this matter you can just declare the mule service and client services dependencies in your pom:
{{{
                <dependency>
			<groupId>org.jsemantic.services</groupId>
			<artifactId>mule-service</artifactId>
			<version>0.1.0-SNAPSHOT</version>
		</dependency>
		<dependency>
			<groupId>org.jsemantic.services</groupId>
			<artifactId>mule-client-service</artifactId>
			<version>0.2.0-SNAPSHOT</version>
		</dependency>
}}}

All the services provided with jEmbedded follows the same packaging pattern,  they provide you with an interface, an implementation, some customs annotations and  a META-INF/xxx-service directory with the needed resources, usually a xxx-service.xml file(to use it from Spring or any other framework that uses its ApplicationContext), some properties files, some other configuration stuff etc... In fact this is the way you should package your services for distribution:

{{{
resources/
         META-INF/
                 xxx-service
                 /....config files
}}}

So basically to use a service you can:

*  Import it using the attribute "resources" with a class/interface depending how it was designed. This way you can externalize the configuration of your service using the @PropertiesService: `resources=MuleServiceImpl.class`

*  Using its custom annotation:

{{{
@MuleService(configurationFile="echo-config.xml")
public Service getMuleService();
}}}

The annotation can be declared at class or method level. If you want to have access to it, the best way it's to declare method that will implemented  by the service at runtime.

{{{
MuleService muleService = echoService.geMuleService();
}}}

Importing the service this way has the restriction that the configuration it's fixed on the annotation. This is not an issue when you want to develop and distribute a service like this one that is not likely to change.


3 - Annotate the methods and add the additional services you may need.

{{{
@AnnotatedService(id="echoMuleService", 
resources=MuleServiceImpl.class, managedElements="muleService")
public interface EchoMuleService extends Service {
	
	@Inject(ref="muleService")
	public MuleService getMuleService();
	
	@PropertiesService(propertiesFile=
             "META-INF/web-server/mule-echo-service.properties")
	public void getPropertiesService();
}
}}}

Note the I added the `PropertiesService` as it's needed to parse the properties file configuration (you can avoid this using the custom annotation). This service is used to add functionality to the service but it's not managed by it. Also you don't need it to declare it as method (I did it for the sake of the example):

{{{

@PropertiesService(propertiesFile=
             "META-INF/web-server/mule-echo-service.properties")

@AnnotatedService(id="echoMuleService", 
resources=MuleServiceImpl.class, managedElements="muleService")
public interface EchoMuleService extends Service {
	
	@Inject(ref="muleService")
	public MuleService getMuleService();
}
}}}

4- At this point we could think that would be nice to add a method that actually invokes the model that mule service exposes. This model just echo whatever string you sent to it so we'll add the following method:

{{{
public Object sendEchoMessage(String echoEndPoint, String message);
}}}

Now you may think that you have to write have an implementation class.. but no you are wrong :), you can implement this functionality just using composition:

{{{
@ImplementedBy(ref="muleClient", refMethodName="sendMessage")
public Object sendEchoMessage(String echoEndPoint, String message);
}}}

`@ImplementedBy annotation:`

- ref: service or element that could implement this functionality (required).

- refMethodName: method of the ref element that needs to be invoked (optional). If it's not provided the declared method name will be used.

In this case we use the @MuleClient service to implement this method (with the paramas endpoint and message).

{{{
echoMuleService.sendEchoMessage("vm://echo", "hello dude!");
}}}

Finally the service looks like this:

{{{
@MuleClient
@AnnotatedService(id="echoMuleService", resources=MuleServiceImpl.class, 
		managedElements="muleService")
public interface EchoMuleService extends Service {
	
	@Inject(ref="muleService")
	public MuleService getMuleService();
	
	@PropertiesService(propertiesFile="META-INF/mule-service/mule-echo-service.properties")
	public void getPropertiesService();
	
	//We add custom functionality, using composition of elements
	@ImplementedBy(ref="muleClient", refMethodName="sendMessage")
	public Object sendEchoMessage(String echoEndPoint, String message);
}
}}}

And a stripped version:

{{{
@AnnotatedService(id="echoMuleService", 
resources=MuleServiceImpl.class, MuleClientWrapperImpl.class,
PropertiesService.class, 
managedElements="muleService")
public interface EchoMuleService extends Service {
		
	@ImplementedBy(ref="muleClient", refMethodName="sendMessage")
	public Object sendEchoMessage(String echoEndPoint, String message);
}
}}}

If you use this version you also will need add the configuration in a properties file in META-INF/repository.properties.

As you can see jEmbedded gives a lot of flexibility in order to configure and compose the services or other elements as components or beans.


4 – Now you have the service to ready to go, but how still you need and environment to run it.

In order to do that you can use the EmbeddedHandlerFactory:

{{{
EmbeddedHandler handler = EmbeddedHandlerFactory.getInstance(Class<?>...…classes);
}}}

The factory accepts an array of classes. You should add here the services or elements you want to add to the container (most likely the entry point).

For example: `EchoMuleService.class` or if you running it from a test unit:

{{{
//note if you not declare the @Respository annotation here, a default repository will
//be created
@Include(resources={EchoMuleService.class}) // include the service into the container
public class TestEchoMuleService {
	
	private EmbeddedHandler handler = null;
	
	@Before
	public void setUp() {
		handler = EmbeddedHandlerFactory.getInstance(getClass());
		handler.start();//start the container
	}
	
	@After
	public void dispose() {
		handler.stop(); //stop and dispose the container
	}
	@Test
	public void test() {
		
		EchoMuleService echoMuleService = (EchoMuleService)handler.getService("echoMuleService");
		
		String result = (String)echoMuleService.sendEchoMessage("vm://echo", "hello dude!");
		assertEquals("hello dude!", result);
	}
}
}}}

5 - Now you can run the service for real using with the jEmbedded plugin.

This plugin is for maven so you need to declare it in your pom:

{{{
	<plugins>
		<plugin>
		<groupId>org.jsemantic.jembedded</groupId>
		<artifactId>jembedded-plugin</artifactId>
		<version>0.2-SNAPSHOT</version>
		<configuration>
			<argLine>-Xms256m -Xmx512m</argLine>

				<additionalClasspathElements>
					<additionalClasspathElement>${basedir}/target/classes</additionalClasspathElement>
				</additionalClasspathElements>	
				<useSystemClassLoader>true</useSystemClassLoader>
					<container>
						<id>test</id>
						<classes>
							<class>org.jsemantic.jembedded.examples.services.mule.EchoMuleService</class>
							
						</classes>
					</container>
				</configuration>
		</plugin>
	</plugins>
}}}

To start the container: `mvn -o jembedded:start`

Once the container it's started, you will prompted to enter something, just do it and you will have your echo, cool huh? ;)

6 - Packaging and distribution.

Now that you have a complete service you may think that you could distribute or reuse it using composition.

In order to this you need to do:

- Create a pom (have a look at any pom provided with the jembedded-services) that will package the classes and resources in a jar.

- Create a custom annotation if you think that could be useful for the users of the service:
{{{
@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE, ElementType.METHOD})
public @interface EchoMuleService {
	/**
	 * 
	 * @return
	 */
	AnnotatedService service() default @AnnotatedService(id="echoMuleService", clazz="org.jsemantic.jembedded.examples.services.mule.EchoMuleService");
	
        //you could declare more properties if needed
}
}}}

This way anyone that wants to use the service only will need to declare the annotation (that it's using jEmbedded that is):

{{{
@EchoMuleService // include the service into the container
public class TestEchoMuleService {
	
	private EmbeddedHandler handler = null;
	
..
}
}}}

- Create a META-INF/echo-mule-service directory and include a properties file for configuration (if needed) and a xml beans file if you are planning to use this service from Spring or any framework that uses Spring's ApplicationContext (as such as Mule):
{{{
<bean id="echoMuleService" class="org.jsemantic.jembedded.support.spring.exporter.ServiceExporter">
		<property name="id" value="echoMuleService"/>
		
		<property name="annotatedClasses">
			<list>
	<value>org.jsemantic.jembedded.examples.services.mule.EchoMuleService</value>
			</list>
		</property>
	</bean>
}}}

To use from Spring just use the import tag:

`<import resource="classpath:META-INF/echo-mule-service/echo-mule-service.xml"/>`