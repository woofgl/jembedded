= Introduction =

The core container provides a set of annotations that allows to configure the different elements of the framework.

The annotations can be imported as separate module if needed, for example to create a new service that doesn't need the whole framework dependency.

Most of the annotations can be used at a method level and at a method level. Some even at a field level.

As it's been told before the container it's a composition of 1-n repositories, so most of the annotations refers to these repositories and to the container. Except the `@Container` annotation that refers only to the Container.


== Container Annotations == 


`@Container`

This annotation allows to configure the core container. Can be declared at a class level and only one annotation is allowed per container.

If no annotation is declared one is created by default:

{{{
@Container(instanceType=ContainerInstanceType.PROTOTYPE_BY_THREAD)

@AbstractService(id="webServer")
public class WebServer {

}
}}}

The above declaration (or the lack of it) means that any thread that accesses the container creation code(see the snippet below) will create a new container and it will be associated with that thread.

{{{
EmbeddedHandler handler = EmbeddedHandlerFactory.getInstance(WebServer.class);
handler.start();
}}}

As that container is associated with the current thread it can be retrieved using of course the declared handler but also from any other class using the class ContainerHolder:

{{{
EmbeddedHandler handler = ContainerHolder.getCurrentThreadContainer();
}}}

This configuration is useful when you need to create a fresh container everytime a new thread is created and disposing the container when the thread is destroyed. For instance, you want to associate a container to a Controller Thread (MVC).

You have to be careful with this type of container though, as if you create another container in the same thread, the older one will be reused and you can get weird behavior.


´@Container´
|| *Attribute* || *Description* || * Values * ||
|| instanceType:ContainerInstanceType || Type of container instance ||PROTOTYPE_BY_THREAD, PROTOTYPE_BY_VM,  SINGLETON_VM||


If you need to have several containers in the same application a safer bet it's to use the PROTOTYPE_BY_VM type. Everytime a container is instanced it's created from scratch and it's not associated with the current thread. Obviously this container can not be accessed through the `ContainerHolder` class.

Finally, if only one instance of the container is needed for the whole application, you need to use the SINGLETON_VM type. Once one instance is created, if another one is created an exception will be thrown (if the previous one hasn't been disposed). The `ContainerHolder` can be used to retrieve the container.


== Container & Repository Annotations == 

@Repository

This annotation it's one of the most important ones, even though you don't need to use it if you don't want.

The jEmbedded container is a composition of 1-n Repositories:

 *A @Repository is a holder for a collection of elements(services, components...) grouped logically or not* 

Obviously @Repository it's much more that just a holder, as it has additional functionality as it can manage the life cycle of the elements that it holds.

So by now it's clear that the basic element of jEmbedded it's the @Repository. In fact, you can create your own Container using them.

In this case jEmbedded is a group of repositories that can be configured as a hierarchy, for instance a hierarchy of layers (group of logical elements). For example, a ServiceLayer whose parent it's an IntegrationLayer. 
The good about this approach it's that an element in the ServicesLayer can have access to elements in the IntegrationLayer, but not the other way.

As I said before you don't need to use this @Repository annotation and that's because one Repository it's created by default if any annotation it's given:

{{{
@WebClient
@PropertiesService

@Include(resources={WebServer.class})
public class IntegrationWebServerTest {

        @Before
	public void init() {
		handler = EmbeddedHandlerFactory.getInstance(getClass());
		handler.start();
	}
}
}}}

In the code above a @Repository is created for you, being the entry point to the IntegrationWebServerTest.class.

The @Include annotation will add the resources to the @Repository and the custom annotations @WebClient and @PropertiesService will have the same effect.

So the equivalent @Repository declaration would be:


{{{
@WebClient
@PropertiesService

@Repository(id="integrationWebServerTest", resources=WebServer.class)
public class IntegrationWebServerTest {

        @Before
	public void init() {
		handler = EmbeddedHandlerFactory.getInstance(getClass());
		handler.start();
	}
}
}}}

Or you can just declare this way just using just the service class declarations:
{{{
@Repository(id="integrationWebServerTest", resources={WebServer.class, 
HttpClient.class, PropertiesService.class})
public class IntegrationWebServerTest {

        @Before
	public void init() {
		handler = EmbeddedHandlerFactory.getInstance(getClass());
		handler.start();
	}
}
}}}


@Repository
|| *Attribute* || *Description* || * Values * ||

|| id || repository id in the container ||String ||
|| resources || elements the repository will hold ||*.class ||
|| managedElements || elements the repository will manage ||collection of Service id's ||
|| parent || parent repository reference || parent repository id in the container ||
 