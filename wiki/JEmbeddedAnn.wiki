= Introduction =

The core container provides a set of annotations that allows to configure the different elements of the framework.

The annotations can be imported as separate module if needed, for example to create a new service that doesn't need the whole framework dependency.

Most of the annotations can be used at a method level and at a method level. Some even at a field level.

As it's been told before the container it's a composition of 1-n repositories, so most of the annotations refers to these repositories and to the container. Except the `@Container` annotation that refers only to the Container.


== Container Annotations == 


`@Container`

This annotation allows to configure the core container. Can be declared at a class level and only one annotation is allowed per container.

If no annotation is declared one is created by default:

{{{
@Container(instanceType=ContainerInstanceType.PROTOTYPE_BY_THREAD)

@AbstractService(id="webServer")
public class WebServer {

}
}}}

The above declaration (or the lack of it) means that any thread that accesses the container creation code(see the snippet below) will create a new container and it will be associated with that thread.

{{{
EmbeddedHandler handler = EmbeddedHandlerFactory.getInstance(WebServer.class);
handler.start();
}}}

As that container is associated with the current thread it can be retrieved using of course the declared handler but also from any other class using the class ContainerHolder:

{{{
EmbeddedHandler handler = ContainerHolder.getCurrentThreadContainer();
}}}

This configuration is useful when you need to create a fresh container everytime a new thread is created and disposing the container when the thread is destroyed. For instance, you want to associate a container to a Controller Thread (MVC).

You have to be careful with this type of container though, as if you create another container in the same thread, the older one will be reused and you can get weird behavior.


´@Container´
|| *Attribute* || *Description* || * Values * ||
|| instanceType:ContainerInstanceType || Type of container instance ||PROTOTYPE_BY_THREAD, PROTOTYPE_BY_VM,  SINGLETON_VM||


If you need to have several containers in the same application a safer bet it's to use the PROTOTYPE_BY_VM type. Everytime a container is instanced it's created from scratch and it's not associated with the current thread. Obviously this container can not be accessed through the `ContainerHolder` class.

Finally, if only one instance of the container is needed for the whole application, you need to use the SINGLETON_VM type. Once one instance is created, if another one is created an exception will be thrown (if the previous one hasn't been disposed). The `ContainerHolder` can be used to retrieve the container.


== Container & Repository Annotations == 

`@Repository`

The 

 