#summary Integration/ESB case study using jEmbedded.

= Case study: Electrical Measures & Invoicing =

Note:
Â´In construction'

So let's say we need to build a quick prototype for the company "Electrical" that wants to implement a new system that will capture the electrical readings in every building and then send it to a central system that will calculate and print the invoices. 

In order to connect to the central system, we'd need a device in every building that gets the readings and send them through the internet.

We can think about that device as an embedded pc system with an IP and an id that will connect to the internet and send the data to the central system through a few protocols. This device will have to get the measures from every home, so we'd still new some electrical meters in place and connect them to the embedded device.

As the "Electrical Co" already has a Invoicing System and doesn't want to replace it, we'll have to use and connect it to the new system. It has a java api to invoke, but no WS api or JMS ect.... therefore we'll have to come up with something that allows to connect to the invoicing system but at the same time that give us flexibility and don't tie the new system to it.

It seems that we got a pretty clear case of System's Integration so using an SOA/Integration architecture is in place. This is not only using an ESB but implementing all the functionality in services using composition when possible.

So how do we build the proyotype? We can just get the ESB and a bunch of frameworks and start integratiog then, etc... but that takes time and certainly don't promote reuse (it's a prototype but still), so why don't use a ready framework for that, that implemens service composition, that has ready to go services, promotes reuse and eases all the integration pain? :)

For instance, if you need to deploy a service or just a class in Mule, after you have created you still have to put the jar in the mule/lib folder, start it ect ect.. you don't need to do this using the framework.

== Prototype ==

First we can define the protocols we'll use to connect to the central system. We could think that JMS over HTTP will be the safest one to use, but for the purposes of the prototype we'll use the  SOAP/HTTP protocol through we services. Also we'll use plain HTTP protocol so we can have another entry point if the web service is not available or just to invoke the invoices system on line through a web application (to correct or create manually an invoice).

Now with the description of the system at hand we can came up with the services, components etc... that we'd need, trying to use as much service composition as possible:

  * Electrical measures devices: they will take the measures and send them to the central system every x days. We'll model them as agents that will connect to the central system through HTPP sending semi random data. As we have an agent-service available we'll use it:

The agent will connect via HTTP, we'll use the HTTP-Client component for that.

  * Central system: it will be created as a composition of several services and entry points.

=== Entry Points ===

There will be 2 entry points to the application: A WS-Enpoint and a HTTP-Entry point. The second one will be represented by a MVC controller (it's url, in fact) and the other as WS-Entry point exposed by the ESB.

In order to model these entry points we'll need a web-server that we can implement using a jetty-service and a ESB than we can implement with the mule-service. Also to implement the entry point controller we'll use SpringMVC that it's supported by jEmbedded natively.


|| *Entry Point* || *Model* || *Implementation* ||
|| WS-Endpoint || ESB || Mule-Service ||
|| HTTP-Endpoint  || Web/Controller || Jetty-Service/Spring MVC ||


=== Services ===

Apart from the services needed to implement the entry point we'll need some business services and other components to implement the application work flow.

It's a good idea to group the application services in a logical fashion, in other words in layers:


- A Service Layer that will work as a facade for the entry points. It's a good idea that the external clients (whatever they might be) access just a facade that shields it from changes and don't expose more than the necessary interface.

The Service Layer will be composed as a hierarchy having as a parent a Persistence Layer and an Integration Layer. This way the service layer will have access to all the services, but for instance the Integration layer won't have access to the persistence layer.

|| *Service* || *Layer* || *Implementation* ||
|| Invoicing Facade || ServicesLayer || AbstractService ||
|| Invoicing Service || ServicesLayer || AbstractService ||
|| Customer Database || PersistenceLayer || Embedded-Database(Derby) ||
|| ESB || IntegrationLayer || Mule-Service ||
|| Messaging Facility  || IntegrationLayer || JMS-Broker-Service ||



|| *Service* || *Model* || *Implementation* ||
|| Invoicing Server || ServicesLayer || Mule-Service ||
|| Customer Database  || Web/Controller || Jetty-Service/Spring MVC ||

== Application Flow. ==

The controller will receive http request with 2 parameters (needed to calculate the invoice) and it will invoke the invoicing-service (in the services-layer). 

This service will get the details of the customer (in the persistence layer) and will  send a message to the invoicing-server with the data (in the integration-layer).

The invoicing-server is composed of a mule-service, an jms broker, a rules-service and the actual invoicing-service (that calculates and creates the invoice).


=== Services Layer ===
{{{

@Repository(id = "serviceLayer", parent = "persistenceLayer")

@AbstractService(id = "serviceLayer", resources={InvoicingService.class},
managedElements="invoicingService")
public interface ServicesLayer extends Service {

	@Inject(ref="invoicingService")
	public InvoicingService getInvoicingService();
}
}}}



The controller looks like this:

{{{
public class Controller extends AbstractController {

	private ServicesLayer servicesLayer = null;

	public void setServicesLayer(ServicesLayer servicesLayer) {
		this.servicesLayer = servicesLayer;
	}

	@Override
	protected ModelAndView handleRequestInternal(HttpServletRequest request,
			HttpServletResponse response) throws Exception {
		Map<String, Object> model = new WeakHashMap<String, Object>();

		String id = (String) request.getParameter("id");
		String kwh = (String) request.getParameter("kwh");

		InvoicingService invoiceService = (InvoicingService) servicesLayer
				.getInvoicingService();
		invoiceService.generateInvoice(id, kwh);

		ModelAndView mv = new ModelAndView("index");
		mv.addAllObjects(model);
		return null;
	}
}
}}}

The controller retrieves and invoke the `InvoicingService` with the http params through messaging:

{{{
@MuleClient
@AnnotatedService(id = "invoicingService")
public class InvoicingServiceImpl extends AbstractCMTService implements
		InvoicingService {
	
	@Inject
	private JdbcService jdbcService = null;

	@Inject
	private MuleClientWrapper muleClient = null;

	public void generateInvoice(String customerId, String kwh) {

		Customer customer = null;
		
                //the customer is retrieved using the jdbcService

		if (customerResult != null) {
			MuleMessage message = new DefaultMuleMessage(customer);
			muleClient.sendMessage("jms://in.queue", message);

			logger.debug(">>>>>>>>>>>>Sent message: " + message
					+ ">>>>>>>>>>>>>>>>>>");
		} else {
			logger.debug(">>>>>>>>>>>>No message sent");
		}
	}

}
}}}

The invoicing service "lives" in the service layer, acting as a mediator to the rest of the services, accessing the persistence layer (to retrieve the customer) and the integration layer to call the invoicing server.

=== Persistence Layer ===

The persistence layer contains the embedded database and the jdbcService

{{{
@Repository(id="persistenceLayer", parent="integrationLayer")

@AnnotatedService(id="persistenceLayer", resources={EmbeddedDatabaseImpl.class})
public interface PersistenceLayer extends Service {

	@PropertiesService(propertiesFile="META-INF/invoicing-server.properties")
	public Service getPropertiesService();
	
}
}}}

=== Integration Layer == 

The integration layer it's the interface to the external systems, in this case it's the invoicing-server that's is handled by a MULE ESB.

The invoicing-server doesn't get all the requests upfront, there is queue that gets all the petitions, a validation-service that validates the msg and then if it's correct it's passed to the invoces-service (if not it's redirected to and error queue).

{{{
@Repository(id = "integrationLayer")
@AnnotatedService(id="integrationLayer", resources={InvoicingServer.class})
public interface IntegrationLayer  extends Service {
	
	@JmsBroker(connector="tcp://localhost:61618")
	public Service getJmsBroker();
	
	@Inject(ref="invoicingServer")
	public InvoicingServer getInvoicingServer();
}

}}}

=== The invoicing-server ===

{{{
@AnnotatedService(id="invoicingServer")
public interface InvoicingServer extends Service {
	
	@MuleService(
			configurationFile="META-INF/invoices-app/services/mule-service/invoicing-system-config.xml")
	public Service getMuleService();
	
}
}}}

So the invoicing server can be created with composition: a mule service, a validation-service and a invoices-service (the one that actually creates the invoices). In the layer it's only declared the mule-service as the rest of services are handled by mule (but both services are created by jEmbedded and imported by mule):

{{{
spring:beans>
   <spring:import resource="classpath:META-INF/invoices-service/invoices-service.xml"/>
   <spring:import resource="classpath:META-INF/validation-service/validation-service.xml"/>
}}}

The validation needs to be referenced by a custom-inbound router:
{{{
<custom-inbound-router 						class="org.jsemantic.jembedded.examples.invoicing.mule.MuleValidationService">
    <spring:property name="validationService" ref="validationService"/>
</custom-inbound-router>
}}}

and the invoices-service will be the core component of the mule model service:

{{{
<service name="invoicingService">
	<inbound>
	   <jms:inbound-endpoint queue="temp.queue"/>
	</inbound>
	<component>
	   <spring-object bean="invoicesService"/>
	</component>
}}}