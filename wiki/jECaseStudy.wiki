#summary Integration/ESB case study using jEmbedded.

= Introduction =

//In construction. all the sources and the resources will be available in the next release of jEmbedded (0.1.2)

An integration service layer needs to be implemented that will act as a facade for a Spring MVC Controller. 

This layer represents the entry to point to an invoicing-server, that calculates the invoices for a number of customers. The invoicing server will be represented by an integration-layer. 

This service layer will be composed as a hierarchy of layers having as a parent a Persistence Layer and an Integration Layer. This way the service layer will have access to all the services, but for instance the Integration layer won't have access to the persince layer.

== Application Flow. ==

The controller will receive http request with 2 parameters (needed to calculate the invoice) and it will retrieve and invoke the invoicing-service (in the services-layer). 

This service will get the details of the customer (in the persistence layer) and will  send a message to the invoicing-server with the data (in the integration-layer).

The invoicing-server is composed of a mule-service, an jms broker, a rules-service and the actual invoicing-service (that calculates and creates the invoice).


=== Services Layer ===
{{{

@Container(instanceType = ContainerInstanceType.PROTOTYPE_VM)

@Repository(id = "serviceLayer", parent="persistenceLayer")
public class ServicesLayer extends AbstractServiceLayer {

	/**
	 * 
	 * @return
	 */
	public InvoicingService getInvoicingService() {
		return (InvoicingService)this.getService("invoicingService");
	}
}

}}}

The controller looks like this:

{{{
public class Controller extends AbstractController {
	
	private ServicesLayer serviceLayer = null;
	
	public void setServiceLayer(ServicesLayer serviceLayer) {
		this.serviceLayer = serviceLayer;
	}

	@Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)
        throws Exception
    {
        Map<String, Object> model = new WeakHashMap<String, Object>();
        
        String id = (String)request.getParameter("id");
        String kwh = (String)request.getParameter("kwh");
        
        InvoicingService invoiceService = (InvoicingService)serviceLayer.getInvoicingService();
        invoiceService.generateInvoice(id, kwh);
     
        return null;
    }
}

}}}

The controller retrieves and invoke the invoicingService with the http params:

{{{
@MuleClient
@AnnotatedService(id = "invoicingService")
public class InvoicingServiceImpl extends AbstractCMTService implements
		InvoicingService {
	
	@Inject
	private JdbcService jdbcService = null;

	@Inject
	private MuleClientWrapper muleClient = null;

	public void generateInvoice(String customerId, String kwh) {

		Customer customer = null;
		
                //the customer is retrieved using the jdbcService

		if (customerResult != null) {
			MuleMessage message = new DefaultMuleMessage(customer);
			muleClient.sendMessage("jms://in.queue", message);

			logger.debug(">>>>>>>>>>>>Sent message: " + message
					+ ">>>>>>>>>>>>>>>>>>");
		} else {
			logger.debug(">>>>>>>>>>>>No message sent");
		}
	}

}
}}}


=== Persistence Layer ===

The persistence layer is integrated with a spring-container that provides the datasource, daos etc...

{{{

@SpringRepository(configurationFile="META-INF/invoices-app/layers/persistence-layer.xml")
		
@PropertiesService(propertiesFile="META-INF/invoicing-server.properties")

@Repository(id="persistenceLayer", resources={EmbeddedDatabaseImpl.class, InvoicingServiceImpl.class}, 
		iocProviders="springProvider", parent="integrationLayer")
		
interface PersistenceLayer{

}
}}}

#summary Integration/ESB case study using jEmbedded.

= Introduction =

//In construction 

An integration service layer needs to be implemented that will act as a facade for a Spring MVC Controller. 

This layer represents the entry to point to an invoicing-server, that calculates the invoices for a number of customers. The invoicing server will be represented by an integration-layer. 

This service layer will be composed as a hierarchy of layers having as a parent a Persistence Layer and an Integration Layer. This way the service layer will have access to all the services, but for instance the Integration layer won't have access to the persince layer.

== Application Flow. ==

The controller will receive http request with 2 parameters (needed to calculate the invoice) and it will retrieve and invoke the invoicing-service (in the services-layer). 

This service will get the details of the customer (in the persistence layer) and will  send a message to the invoicing-server with the data (in the integration-layer).

The invoicing-server is composed of a mule-service, an jms broker, a rules-service and the actual invoicing-service (that calculates and creates the invoice).


=== Services Layer ===
{{{

@Container(instanceType = ContainerInstanceType.PROTOTYPE_VM)

@Repository(id = "serviceLayer", parent="persistenceLayer")
public class ServicesLayer extends AbstractServiceLayer {

	/**
	 * 
	 * @return
	 */
	public InvoicingService getInvoicingService() {
		return (InvoicingService)this.getService("invoicingService");
	}
}

}}}

The controller looks like this:

{{{
public class Controller extends AbstractController {
	
	private ServicesLayer serviceLayer = null;
	
	public void setServiceLayer(ServicesLayer serviceLayer) {
		this.serviceLayer = serviceLayer;
	}

	@Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)
        throws Exception
    {
        Map<String, Object> model = new WeakHashMap<String, Object>();
        
        String id = (String)request.getParameter("id");
        String kwh = (String)request.getParameter("kwh");
        
        InvoicingService invoiceService = (InvoicingService)serviceLayer.getInvoicingService();
        invoiceService.generateInvoice(id, kwh);
     
        return null;
    }
}

}}}

The controller retrieves and invoke the invoicingService with the http params:

{{{
@MuleClient
@AnnotatedService(id = "invoicingService")
public class InvoicingServiceImpl extends AbstractCMTService implements
		InvoicingService {
	
	@Inject
	private JdbcService jdbcService = null;

	@Inject
	private MuleClientWrapper muleClient = null;

	public void generateInvoice(String customerId, String kwh) {

		Customer customer = null;
		
                //the customer is retrieved using the jdbcService

		if (customerResult != null) {
			MuleMessage message = new DefaultMuleMessage(customer);
			muleClient.sendMessage("jms://in.queue", message);

			logger.debug(">>>>>>>>>>>>Sent message: " + message
					+ ">>>>>>>>>>>>>>>>>>");
		} else {
			logger.debug(">>>>>>>>>>>>No message sent");
		}
	}

}
}}}


=== Integration Layer ===

{{{
@Repository(id = "integrationLayer")

@JmsBroker(connector="tcp://localhost:61618")
@MuleService(configurationFile="META-INF/invoices-app/services/mule-service/invoicing-system-config.xml")
public interface IntegrationLayer  {

}
}}}


As all the services are provided by the container out of the box you can compose an create the layers pretty fast (at least for a prototype).

=== The invoicing-sever ===

// TO DO

}}}