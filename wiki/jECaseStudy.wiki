#summary Integration/ESB case study using jEmbedded.

= Case study: Electrical Measures & Invoicing =

So let's say we need to build a quick prototype for the company "Electrical" that wants to implement a new system that will capture the electrical readings in every building and then send it to a central system that will calculate and print the invoices. 

In order to connect to the central system, we'd need a device in every building that gets the readings and send them through the internet.

We can think about that device as an embedded pc system with an IP and an id that will connect to the internet and send the data to the central system through a few protocols. This device will have to get the measures from every home, so we'd still new some electrical meters in place and connect them to the embedded device.

As the "Electrical Co" already has a Invoicing System and doesn't want to replace it, we'll have to use and connect it to the new system. It has a java api to invoke, but no WS api or JMS ect.... therefore we'll have to come up with something that allows to connect to the invoicing system but at the same time that give us flexibility and don't tie the new system to it.

It seems that we got a pretty clear case of System's Integration so using an SOA/Integration architecture is in place. This is not only using an ESB but implementing all the functionality in services using composition when possible.

So how do we build the proyotype? We can just get the ESB and a bunch of frameworks and start integratiog then, etc... but that takes time and certainly don't promote reuse (it's a prototype but still), so why don't use a ready framework for that, that implemens service composition, that has ready to go services, promotes reuse and eases all the integration pain? :)

For instance, if you need to deploy a service or just a class in Mule, after you have created you still have to put the jar in the mule/lib folder, start it ect ect.. you don't need to do this using the framework.

== Prototype ==

First we can define the protocols we'll use to connect to the central system. We could think that JMS over HTTP will be the safest one to use, but for the purposes of the prototype we'll use the  SOAP/HTTP protocol through we services. Also we'll use plain HTTP protocol so we can have another entry point if the web service is not available or just to invoke the invoices system on line through a web application (to correct or create manually an invoice).

Now with the description of the system at hand we can came up with the services, components etc... that we'd need, trying to use as much service composition as possible:

  * Electrical measures devices: they will take the measures and send them to the central system every x days. We'll model them as agents that will connect to the central system through HTPP sending semi random data. As we have an agent-service available we'll use it:

The agent will connect via HTTP, we'll use the HTTP-Client component for that.

  * Central system: it will be created as a composition of several services and entry points.
  * Invoicing system: a composition of services + the provided invoices-service.
 
=== Entry Points ===

There will be 2 entry points to the application: A WS-Enpoint and a HTTP-Entry point. The second one will be represented by a MVC controller (it's url, in fact) and the other as WS-Entry point exposed by the ESB.

In order to model these entry points we'll need a web-server that we can implement using a jetty-service and a ESB than we can implement with the mule-service. Also to implement the entry point controller we'll use SpringMVC that it's supported by jEmbedded natively.


|| *Entry Point* || *Model* || *Implementation* ||
|| WS-Endpoint || ESB || Mule-Service ||
|| HTTP-Endpoint  || Web/Controller || Jetty-Service/Spring MVC ||

=== Services ===

Apart from the services needed to implement the entry points we'll need some business services and other components to implement the application work flow.

It's a good idea to group the application services in a logical fashion, in other words in layers:

- A Service Layer that will work as a facade for the entry points. It's a good idea that the external clients (whatever they might be) access just a facade that shields it from changes and don't expose more than the necessary interface.

The Service Layer will be composed as a hierarchy having as a parent a Persistence Layer and an Integration Layer. This way the service layer will have access to all the services, but for instance the Integration layer won't have access to the persistence layer.

- A Persistence Layer that will hold the customer database (a derby embedded database) and the necessary DAO's to retrieve the data. We'll implement this layer using Spring to take advantage of it's transactional services and to show the jEmbedded integration

- A Integration Layer that's the interface to the external systems, in this case it's the Invoicing-Server that's is modelled by composition of a few services.

|| *Service* || *Layer* || *Implementation* ||
|| Invoicing Facade || ServicesLayer || AbstractService ||
|| Invoicing Service || ServicesLayer || AbstractService ||
|| Customer Database || PersistenceLayer || Embedded-Database(Derby) ||
|| Customer DAO || PersistenceLayer || SpringJDBC ||
|| ESB || IntegrationLayer || Mule-Service ||
|| Messaging Facility  || IntegrationLayer || JMS-Broker-Service ||

All the layers are implemented using AbstractServices and composition so there is no need of any implementation (just the interface).

- Invoicing server

|| *Service* || *Model* || *Implementation* ||
|| Invoicing Server || Mule-Model || Abstract Service ||
|| Customer validator  || Mule-Model || Mule-Validation-Service ||
|| Invoices Service  || Mule-Model || Invoices Service (provided) ||


== Application Flow. ==

The requests sent by the measure agents will be received from any of the 2 entry points. If the http entry point received a request, a controller will be invoked with the two parameters needed to calculate the invoice. The controller has access to the Service Layer and its facade invoking the Invoicing Service facade.

This service is implemented using an AbstractService and jBPM process, that basically retrieves the customer data and sends it to the invoicing-server using the messaging-service. The only implementation needed here it's the DAO and that also could be generated for the most part.

Once the Invoicing-Server receives the customer data in it's inbound queue, this Customer Data is validated buy the Mule-Validation-Service. If the data it's wrong, it will dispatched to a error queue. If it's correct it will be dispatched to the invoices-service, that will generate the invoice and then send it to the outbound queue and store the invoice in a xml format in a directory.

== Implementation == 

=== Services Layer ===
{{{

@Repository(id = "serviceLayer", parent = "persistenceLayer")

@AbstractService(id = "serviceLayer", resources={InvoicingService.class},
managedElements="invoicingService")
public interface ServicesLayer extends Service {

	@Inject(ref="invoicingService")
	public InvoicingService getInvoicingService();
}
}}}


The controller looks like this:

{{{
public class Controller extends AbstractController {

	private ServicesLayer servicesLayer = null;

	public void setServicesLayer(ServicesLayer servicesLayer) {
		this.servicesLayer = servicesLayer;
	}

	@Override
	protected ModelAndView handleRequestInternal(HttpServletRequest request,
			HttpServletResponse response) throws Exception {
		Map<String, Object> model = new WeakHashMap<String, Object>();

		String id = (String) request.getParameter("id");
		String kwh = (String) request.getParameter("kwh");

		InvoicingService invoiceService = (InvoicingService) servicesLayer
				.getInvoicingService();
		invoiceService.generateInvoice(id, kwh);

		ModelAndView mv = new ModelAndView("index");
		mv.addAllObjects(model);
		return null;
	}
}
}}}

The controller retrieves and invoke the `InvoicingService` with the http params:

{{{
@MuleClient
@PropertiesService(propertiesFile="META-INF/invoicing-server.properties")
@AbstractService (id="invoicingService", resources={JBPMServiceImpl.class}, 
		managedElements={"jbpmService"})
public interface InvoicingService extends Service {
	
	
	@ImplementedByBPM(bpmServiceRef="jbpmService", processKey="invoicing")
	public void generateInvoice(String customerId, String kwh);
	
}
}}}



The invoicing service "lives" in the service layer, acting as a mediator to the rest of the services, accessing the persistence layer (to retrieve the customer) and the integration layer to call the invoicing server. This is done by a jBPM process:

{{{
<?xml version="1.0" encoding="UTF-8"?>

<process name="invoicing" xmlns="http://jbpm.org/4.0/jpdl">

  <start g="147,55,48,48">
    <transition to="invoke"/>
  </start>
   
  <java expr="#{customerDao}" method="getInvoiceCustomerData" name="invoke" var="result_service_1" g="129,139,80,40">
   		<arg><object expr="#{service_param_0}"/></arg>
   		<arg><object expr="#{service_param_1}"/></arg>
   		<transition name="to_invoke" to="invoke2" g="-52,-18"/>
  </java>
   
  <java expr="#{muleClient}" g="120,226,99,52" method="sendObjectMessage" name="invoke2" var="result_service_end">
    
    <arg><object expr="jms://in.queue"/></arg>
    <arg><object expr="#{result_service_1}"/></arg>
    <transition to="wait"/>
  </java>
  
  <state g="125,321,88,52" name="wait">
   <transition to="end"/>
  </state>
  
  <end g="148,415,48,48" name="end"/>

</process>
}}}


=== Persistence Layer ===

The persistence layer contains the embedded database and the DAO's.

{{{
@Repository(id="persistenceLayer",  iocProviders = { "springRepository" },
		parent="integrationLayer")

@AbstractService(id="persistenceLayer", resources={EmbeddedDatabase.class}, 
		managedElements="embeddedDatabase")
public interface PersistenceLayer extends Service {

	@PropertiesService(propertiesFile="META-INF/invoicing-server.properties")
	public Service getPropertiesService();
	
	@SpringRepository(configurationFile = "META-INF/invoices-app/layers/persistence-layer.xml")
	public Service getSpringRepository();
}
}}}

=== Integration Layer == 

The integration layer it's the interface to the external systems, in this case it's the invoicing-server that's is handled by a MULE ESB.

The invoicing-server doesn't get all the requests upfront, there is queue that gets all the petitions, a validation-service that validates the msg and then if it's correct it's passed to the invoces-service (if not it's redirected to and error queue).

{{{
@Repository(id = "integrationLayer")
@AbstractService(id="integrationLayer", resources={InvoicingServer.class}, 
		managedElements={"invoicingServer", "jmsBrokerService"})
public interface IntegrationLayer  extends Service {
	
	@JmsBroker(connector="tcp://localhost:61618")
	public Service getJmsBroker();
	
	@Inject(ref="invoicingServer")
	public InvoicingServer getInvoicingServer();
}
}}}

=== The invoicing-server ===

{{{
@AbstractService(id="invoicingServer", managedElements="muleService")
public interface InvoicingServer extends Service {
	
	@MuleService(
			configurationFile="META-INF/invoices-app/services/mule-service/invoicing-system-config.xml")
	public Service getMuleService();
	
}
}}}

So the invoicing server can be created with composition: a mule service, a validation-service and a invoices-service (the one that actually creates the invoices). In the layer it's only declared the mule-service as the rest of services are handled by mule (but both services are created by jEmbedded and imported by mule):

{{{
spring:beans>
   <spring:import resource="classpath:META-INF/invoices-service/invoices-service.xml"/>
   <spring:import resource="classpath:META-INF/validation-service/validation-service.xml"/>
}}}

The validation needs to be referenced by a custom-inbound router:
{{{
<custom-inbound-router 						class="org.jsemantic.jembedded.examples.invoicing.mule.MuleValidationService">
    <spring:property name="validationService" ref="validationService"/>
</custom-inbound-router>
}}}

and the invoices-service will be the core component of the mule model service:

{{{
<service name="invoicingService">
	<inbound>
	   <jms:inbound-endpoint queue="temp.queue"/>
	</inbound>
	<component>
	   <spring-object bean="invoicesService"/>
	</component>
}}}