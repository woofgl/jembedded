= Introduction =

jEmbedded was born out of the necessity to use a container on the go, lighter and faster.

As I work as an Architect I find myself doing a lot of prototypes for applications or just trying new technologies so I need to create stuff pretty fast and if it doesn't work trying another one.

Many times this is not possible, because you have to install servers, frameworks, create services etc.. and then glue it all. Just try to make an Integration/SOA prototype with Mule (that is great by the way, hands off to the developers), you have to code, compile then copy the jars to the lib, setup the other servers you may need etc etc and then run, test, error.. you know what I mean.

First I designed jIntegration-Test, a integration testing framework to test the prototypes faster. That was good, I saved sometime but still I missed the possibility to compose this prototypes in a fast and reusable way, so I didn't have to start from scratch every time and in some way avoiding to install all that additional servers.

So that was how I designed jEmbedded, as a container for services (embedded or not) or other elements, that promotes re usability and composition and easy configuration. I started to code a few embedded services (services that run in the same VM) as a Web Server, a Embedded Database, a Mule Service etc.. so I didn't need to install them in my environment. And jEmbeded was born.


So what you can do with jEmbedded:

- Business services container: create and manage your application business services, managing then in a layer integrated with Spring (aop, tx, hibernate..).

- Integration Container: as container for application integration, using an ESB, messaging services etc...

- Rich Applications Container: integrated with GWT/Spring MVC to create RIA applications (SOA oriented).

- Rich Portal Application Provider: introducing the concepts of Gwlets/Widglets to power RIA portals.

-Web enviroment: can be used in any web enviroment, as a holder of a services layer, for example. Have a look at the case study example as it shows the provided integration with SpringMVC.

- Standalone container: implementing services (just one or a layer hierarchy), that you can use in any application (for instance a Swing or a SWT based application).

- Integrated with Spring: you can access Spring bean using the native integration provided by jEmbedded or just creating a`@SpringContext` as another service within the container. This service wraps a Spring Application Context giving easy access to its beans through the wrapper.

- Easy prototyping: create services faster and test them with the test integration infrastructure included within the container and services. 