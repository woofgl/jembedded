#labels Featured,Phase-Implementation,Phase-Deploy
#Embedded Database Integration Test.

= Using the Database Integration Test=

This test provides an Database Service that allows to test real DAO's, JDBC code etc... using a embedded database. Also it provides a JDBC Service (to execute querys and updates) and a Transactional Service. 

The embedded database could be either HSQLDB (in memory ) or Derby (using files).

The simplest use of this test would be using just the annotation `@DatabaseServiceConfiguration` with the default values. It produces a embedded HSQLDB database (_jdbc:hsqldb:mem:test_) and a JDBCService to launch the query's. 

@DatabaseServiceConfiguration Annotation usage:

* provider: embedded database provided. By default is `org.jsemantic.services.databaseservice.datasource.hsqldb.HsqldbDataSource`. The alternative provider is `DerbyDataSource`.`*`
 
* database: database ulr location. By default is `jdbc:hsqldb:mem:test`.`*`
* user: database connection user. By default is sa.`*`
* password: database connection password. By default is "".`*`
* databaseCreationScript: location of a sql script to create the test schema.`*`
* dataCreationScript: location of a sql script to populate the test schema.`*`
* doCleanUp: intended for Derby database provider, to clean up the database files. By default it's `*`
* createSchema: by default it's `*`


In order to access the services provided by annotation the test must extends the class `AbstractDatabaseIntegrationTest`:

* AbstractDatabaseIntegrationTest.getJdbcService() :: JDBCService `*`
* AbstractDatabaseIntegrationTest.getDatabaseService():: DatabaseService `*`

Also the abstract test class provides some useful testing methods (apart from the standard JUnit4 ones):

* assertResultNotNull(String query, Object... args) `*`
* assertResultListNull(String query, Object... args) `*`
* assertEqualsUpdateResult(String query, int result, Object... args) `*`
* assertFieldEquals(String query, String fieldName, Object expected, Object... args) `*`
* ... `*`

Of course you don't need to use the former ones, as you can execute your own queries and test the results using the standard methods from JUnit4.

For example:

{{{

@DatabaseServiceConfiguration
public class AnnotatedSimpleDatabaseIntegrationTest extends AbstractDatabaseIntegrationTest {
	
	@Test
	public void testInfrastructure() {
		assertNotNull(getDatabaseService());
		assertNotNull(getJdbcService());
	}

     	@Test
	public void test() throws Exception {
		createTable();
		assertEqualsUpdateResult(
		"insert into test values(3, 'test3', 'Test3 description')",
						1);
		
		assertResultNotNull("select * from test where id = 3");
	}
	
	private void createTable() {
		getJdbcService().executeUpdate("CREATE TABLE test" + "(id INTEGER IDENTITY, "+ "	name VARCHAR(25), " + "	description VARCHAR(56))");
	}

}}}

In the example above the table is created using the Jdbc Service provided. This is not need to be always the case as can be seen in the next example.


= Details =

Using Spring (to retrieve a DAO) and a Embedded Derby Database with two SQL scripts (one to create the table another to populate it).


{{{

@SpringContext(configurationFile = "classpath:META-INF/derby-application-context.xml")
@DatabaseServiceConfiguration(database = "test", 
		databaseCreationScript = "database.sql", 
		dataCreationScript = "data.sql", 
		provider="org.jsemantic.services.databaseservice.datasource.derby.DerbyDataSource")
		
public class AnnotatedDerbyDatabaseSpringIntegrationTest extends
		AbstractDatabaseIntegrationTest {

	private TestDAO dao = null;

	@Override
	protected void init() throws Exception {
		super.init();
		dao = (TestDAO) getContainer().getBean("testDAO");
	}
	
	@Test
	public void testInfrastructure() {
		assertNotNull(getContainer());
		assertNotNull(getDatabaseService());
		assertNotNull(getJdbcService());
	}
	
	@Test
	public void test() throws Exception {
		dao.executeUpdate("insert into test values(?,?, ?)", new Object[] { 4,
				"Test 4", "Test Description Number 4" });

		getJdbcService().executeUpdate(
				"insert into test values(?,?, ?)",
				new Object[] { 5, "Test 5", "Test Description Number 5" });

		getJdbcService().executeQueryForList(
				"select * from test");

		assertResultNotNull("select * from test where id=4");
	}
	
	@Test
	public void test2() throws Exception {
		dao.executeUpdate("insert into test values(?,?, ?)", new Object[] { 4,
				"Test 4", "Test Description Number 4" });

		assertResultNotNull("select * from test where id=4");
	}
}

}}}