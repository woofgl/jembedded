#labels Featured,Phase-Implementation,Phase-Deploy
= Using the Database Integration Test =

This test provides a Database Service that allows to test real DAO's, JDBC code etc... using a embedded database. Also it provides a JDBC Service (to execute querys and updates) and a Transactional Service. The embedded database provided could be either HSQLDB (in memory) or Derby (using files).

The simplest use of this test would be using just the annotation `@DatabaseServiceConfiguration` with default values. It produces a embedded HSQLDB database (`_jdbc:hsqldb:mem:test_`) pluse a JDBCService to execute the query's. 

== @DatabaseServiceConfiguration Annotation usage ==

- _provider:_ embedded database provided. By default is `org.jsemantic.services.databaseservice.datasource.hsqldb.HsqldbDataSource`. The alternative provider is `DerbyDataSource`.
 
- _database:_ database ulr location. By default is `jdbc:hsqldb:mem:test`.

- _user:_ database connection user. By default is sa.

- _password:_ database connection password. By default is "".

- _databaseCreationScript:_ location of a sql script to create the test schema.

- _dataCreationScript:_ location of a sql script to populate the test schema.

- _doCleanUp:_ intended for the Derby database provider to clean up the database files. By default it's true.

- _createSchema:_ creates the schema if the scripts are provided. By default it's true.


== Services Provided == 

In order to access the services provided by the annotation the test must extends the class `AbstractDatabaseIntegrationTest`:

- _AbstractDatabaseIntegrationTest.getJdbcService() :: JDBCService_

- _AbstractDatabaseIntegrationTest.getDatabaseService():: DatabaseService_


Also the abstract test class provides some useful testing methods (apart from the standard JUnit4 ones):

- _assertResultNotNull(String query, Object... args)_

- _assertResultListNull(String query, Object... args)_

- _assertEqualsUpdateResult(String query, int result, Object... args)_

- _assertFieldEquals(String query, String fieldName, Object expected, Object... args)_

- ... 

Of course you don't need to use the former methods as you can execute your own queries and test the results against the standard methods from JUnit4.


=== Example 1: Simple Test ===

{{{

@DatabaseServiceConfiguration
public class AnnotatedSimpleDatabaseIntegrationTest extends AbstractDatabaseIntegrationTest {
	
	@Test
	public void testInfrastructure() {
		assertNotNull(getDatabaseService());
		assertNotNull(getJdbcService());
	}

     	@Test
	public void test() throws Exception {
		createTable();
		assertEqualsUpdateResult(
		"insert into test values(3, 'test3', 'Test3 description')",
						1);
		
		assertResultNotNull("select * from test where id = 3");
	}
	
	private void createTable() {
		getJdbcService().executeUpdate("CREATE TABLE test" + "(id INTEGER IDENTITY, "+ "	name VARCHAR(25), " + "	description VARCHAR(56))");
	}

}}}

In the example above the table is created using the Jdbc Service provided. This is not need to be always the case as can be seen in the next example.


=== Example 2: Using scripts to create the embedded database ===

In this example the database and the data are created using sql scripts.

{{{

@DatabaseServiceConfiguration(database = "jdbc:hsqldb:mem:test", 
databaseCreationScript = "META-INF/integration-database-test/scripts/database-hsqldb.sql", 
dataCreationScript = "META-INF/integration-database-test/scripts/data.sql")
public class AnnotatedDatabaseIntegrationTest extends
		AbstractDatabaseIntegrationTest {
	
	@Test
	public void testInfrastructure() {
		assertNotNull(getDatabaseService());
		assertNotNull(getJdbcService());
	}
	
	@Test
	public void testSelect() throws Exception {
		assertEqualsUpdateResult(
		"insert into test values(4, 'test4', 'test description 4')",
				1);
		assertResultNotNull("select * from test where id=4");
	}
	
	@Test
	public void equalsTest() throws Exception {
		assertFieldEquals("select * from test where id=1", "name", "test1");
	}

}

}}}


=== Example 3: Using a Spring Container and a Derby Embedded Database ===

In order to test DAO'S from a Spring Context the Annotation @SpringContext is used. It needs the location of the Spring Context file. 

Once the test has started  the Spring Container can be accesed using the method `getContainer()` of the `AbstractDatabaseIntegrationTest` class.

In this example a Embedded Derby database is used. In order to do that the provider parameter must be provided. The usage of the test is just the same af it the database used were HSQLDB.


{{{

@SpringContext(configurationFile = "classpath:META-INF/derby-application-context.xml")
@DatabaseServiceConfiguration(database = "test", 
		databaseCreationScript = "database.sql", 
		dataCreationScript = "data.sql", 
		provider="org.jsemantic.services.databaseservice.datasource.derby.DerbyDataSource")
		
public class AnnotatedDerbyDatabaseSpringIntegrationTest extends
		AbstractDatabaseIntegrationTest {

	private TestDAO dao = null;

	@Override
	protected void init() throws Exception {
		super.init();
		dao = (TestDAO) getContainer().getBean("testDAO");
	}
	
	@Test
	public void testInfrastructure() {
		assertNotNull(getContainer());
		assertNotNull(getDatabaseService());
		assertNotNull(getJdbcService());
	}
	
	@Test
	public void test() throws Exception {
		dao.executeUpdate("insert into test values(?,?, ?)", new Object[] { 4,
				"Test 4", "Test Description Number 4" });

		getJdbcService().executeUpdate(
				"insert into test values(?,?, ?)",
				new Object[] { 5, "Test 5", "Test Description Number 5" });

		getJdbcService().executeQueryForList(
				"select * from test");

		assertResultNotNull("select * from test where id=4");
	}
	
	@Test
	public void test2() throws Exception {
		dao.executeUpdate("insert into test values(?,?, ?)", new Object[] { 4,
				"Test 4", "Test Description Number 4" });

		assertResultNotNull("select * from test where id=4");
	}
}

}}}