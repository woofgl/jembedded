= Introduction =

jEmbedded it's a complete SOC container (IoC based) that you can use alone if you want or need as also provides a lot of different services that should cover most of the usual needs for a project (well, and integration/soa/ria project).

But it's highly likely that you won't use this alone but with other frameworks as a service provider etc... and for sure one of this frameworks would be Spring as this would let you to use jEmbedded with other frameworks using Spring as a bridge (for instance, I integrated  jEmbedded with Mule this way because Mule configuration files are in fact Spring context files). And because it's most popular framework out there :)


So I provided a few ways to integrate jEmbedded with Spring, one of them native through the jEmbedded context. In other words, jEmbedded (or some of its services) would live in the Spring context allowing Spring beans to have access to them. You could have a service layer exported to the Spring context file so it can be invoked or injected by any Spring bean. This way Spring would be the main container using jEmbedded as a helper one.


The other way it's using a @SpringContext annotation to which you specify the location of the Spring context file you'd like to use. Then you could inject any bean of the Spring context to the jEmbedded services using the @Inject(ref="springBeanId"). This way jEmbedded it's the main container using Spring as a helper one.


== How to use the Spring integration ==

Even though the Spring integration it's native (as it's made through jEmbedded Spring context) I decided to put it in a different module just in case you are not using it: 

{{{                
                 <dependency>
			<groupId>org.jsemantic.jembedded</groupId>
			<artifactId>jembedded-spring-support</artifactId>
			<version>0.1-SNAPSHOT</version>
		</dependency>
}}}


Then you'd need to decide which way it's better for your purposes. If you'd already have a Spring context or a project that uses it maybe it's better to use the jEmbedded export container/services facility into the Spring context. This way Spring would act as the main container having access to the embedded services you just exported (or the whole jEmbedded container).

On the other hand if you are not using Spring or just need it in order to use one of it's facilities maybe it's better to use the @SpringContext annotation and let jEmbedded be the main container. The Spring beans would be available to the jEmbedded services and resources using the @Inject annotation.

== Exporting Services. Spring as a the main Container == 

Basically you need to put the services into the Spring context and for that I provided a few configurations in the Spring way: as xml beans file.

As usual you can find some reference configurations in the META-INF directory of the service, in this case it's a support module but still. These are only reference configurations you can use your own ones.

== Exporting the Container == 

If you'd like to have the jEmbedded container as a whole available for your Spring beans you'd need to use the `EmbeddedContainerRunner` bean (as it will start the container for you, not only will export it).

`EmbeddedContainerRunner bean`
|| *Attribute* || *Description* || * Values * ||
|| id || Id in the spring context || handler||
|| class || Implementation class of the runner|| org.jsemantic.jembedded.support.spring.EmbeddedContainerRunner||
|| annotatedClasses || Classes to be processed by jEmbedded || any list of services||
|| autoStarted || Whether the container should be started || boolean, true by default||

For example we'd like to inject the `EmbeddedHandler` into a Spring bean:

{{{
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
		
	<bean id="handler" class="org.jsemantic.jembedded.support.spring.EmbeddedContainerRunner">
		<property name="annotatedClasses">
			<list>
				<value>org.jsemantic.service.SomeService</value>
				<value>org.jsemantic.service.AnotherService</value>
			</list>
		</property>
	</bean>

</beans>

}}}

And a Spring bean that injects it:

{{{

public class SomeSpringBean {

private EmbeddedHandler handler = null;

public void setEmbeddedHandler(EmbeddedHandler handler)
this.handler = handler;
}

public SomeService getSomeService() {
return handler.getService("someService");
}

public void doSomething() {

getSomeService().execute();
}
}}}

== Exporting Services == 

You don't need to export the whole container, you can export a few services if you like using the `ServiceExporter" bean.

`ServiceExporter bean`
|| *Attribute* || *Description* || * Values * ||
|| bean id || Service id in the Spring context || Service id||
|| class || Implementation class of exporter|| org.jsemantic.jembedded.support.spring.exporter.ServiceExporter||
|| annotatedClasses || Classes to be processed by jEmbedded || any list of services||
|| property id || Service id in the jEmbedded container || Service id||

For example, from the validation-service:

{{{
<bean id="validationService" class="org.jsemantic.jembedded.support.spring.exporter.ServiceExporter">
		<property name="id" value="validationService"/>
		
		<property name="annotatedClasses">
			<list>
				<value>org.jsemantic.services.validationservice.impl.ValidationServiceImpl</value>
			</list>
		</property>
	</bean>
}}}


And a Spring bean that injects it:

{{{
public class SomeSpringBean {

private ValidationService validationService = null;

public void setValidationService(ValidationService validationService)
this.validationService = validationService;
}

public void validate(Object obj) {
validationService.validate(obj);
}
}}}

== Exporting a Service Layer == 

If you had configured your services in layers (have a look at the jEmbedded examples and the case study) it's a good idea to export just the `ServicesLayer` and then injecting it into a Spring bean, for example in a Spring MVC controller. This way jEmbedded would act as services middleware. In order to do this (you could do using the services exported as well) you'd need to use the `ServiceLayerExporter`.

`ServiceLayerExporter bean`
|| *Attribute* || *Description* || * Values * ||
|| bean id || Service Layer id in the Spring context || Service Layer id||
|| class || Implementation class of the layer exporter|| org.jsemantic.jembedded.support.spring.exporter.ServiceLayerExporter||
|| annotatedClasses || Layers to be processed by jEmbedded || any list of layers||
|| exportedLayer || Layer id in the jEmbedded container || Layer id||

For example, from the invoicing-server (case study, services-layer.xml):

{{{
<bean id="servicesLayer" class="org.jsemantic.jembedded.support.spring.exporter.ServiceLayerExporter">
		<property name="exportedLayer" value="serviceLayer"/>
		<property name="annotatedClasses">
			<list>
				<value>${layer.integration}</value>
				<value>${layer.services}</value>
			</list>
		</property>
	</bean>

<bean id="agentInvoicesService" class="org.jsemantic.jembedded.examples.invoicing.controller.InvoicesAgentService">
		<property name="servicesLayer" ref="servicesLayer"/>
</bean>

}}}

and the the Spring bean that injects it (it's a GWT controller):

{{{
public class InvoicesAgentService extends GWTController implements AgentGWTService {
	
	private ServicesLayer servicesLayer = null;

	public void setServicesLayer(ServicesLayer servicesLayer) {
		this.servicesLayer = servicesLayer;
	}

	public InvoiceDTO checkInvoices() {
		return servicesLayer.getInvoicesData();
	}

}
}}}

This way you could use jEmbedded as a provider of services using layers, and Spring for MVC etc etc..

Finally


